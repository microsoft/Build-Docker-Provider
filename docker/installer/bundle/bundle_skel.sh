#!/bin/sh
#
#
# This script is a skeleton bundle file for primary platforms the docker
# project, which only ships in universal form (RPM & DEB installers for the
# Linux platforms).
#
# Use this script by concatenating it with some binary package.
#
# The bundle is created by cat'ing the script in front of the binary, so for
# the gzip'ed tar example, a command like the following will build the bundle:
#
#     tar -czvf - <target-dir> | cat sfx.skel - > my.bundle
#
# The bundle can then be copied to a system, made executable (chmod +x) and
# then run.  When run without any options it will make any pre-extraction
# calls, extract the binary, and then make any post-extraction calls.
#
# This script has some usefull helper options to split out the script and/or
# binary in place, and to turn on shell debugging.
#
# This script is paired with create_bundle.sh, which will edit constants in
# this script for proper execution at runtime.  The "magic", here, is that
# create_bundle.sh encodes the length of this script in the script itself.
# Then the script can use that with 'tail' in order to strip the script from
# the binary package.
#
# Developer note: A prior incarnation of this script used 'sed' to strip the
# script from the binary package.  That didn't work on AIX 5, where 'sed' did
# strip the binary package - AND null bytes, creating a corrupted stream.
#
# Docker-specific implementaiton: Unlike CM & OM projects, this bundle does
# not install OMI.  Why a bundle, then?  Primarily so a single package can
# install either a .DEB file or a .RPM file, whichever is appropraite.

PATH=/usr/bin:/usr/sbin:/bin:/sbin
umask 022

# Note: Because this is Linux-only, 'readlink' should work
SCRIPT="`readlink -e $0`"
set +e

# These symbols will get replaced during the bundle creation process.
#
# The PLATFORM symbol should contain ONE of the following:
#       Linux_REDHAT, Linux_SUSE, Linux_ULINUX
#
# The CONTAINER_PKG symbol should contain something like:
#       docker-cimprov-1.0.0-1.universal.x86_64  (script adds rpm or deb, as appropriate)

PLATFORM=<PLATFORM_TYPE>
CONTAINER_PKG=<CONTAINER_PKG>
SCRIPT_LEN=<SCRIPT_LEN>
SCRIPT_LEN_PLUS_ONE=<SCRIPT_LEN+1>

usage()
{
    echo "usage: $1 [OPTIONS]"
    echo "Options:"
    echo "  --extract              Extract contents and exit."
    echo "  --force                Force upgrade (override version checks)."
    echo "  --install              Install the package from the system."
    echo "  --purge                Uninstall the package and remove all related data."
    echo "  --remove               Uninstall the package from the system."
    echo "  --restart-deps         Reconfigure and restart dependent services (no-op)."
    echo "  --upgrade              Upgrade the package in the system."
    echo "  --version              Version of this shell bundle."
    echo "  --version-check        Check versions already installed to see if upgradable."
    echo "  --debug                use shell debug mode."
    echo "  -? | --help            shows this usage text."
}

cleanup_and_exit()
{
    if [ -n "$1" ]; then
        exit $1
    else
        exit 0
    fi
}

check_version_installable() {
    # POSIX Semantic Version <= Test
    # Exit code 0 is true (i.e. installable).
    # Exit code non-zero means existing version is >= version to install.
    #
    # Parameter:
    #   Installed: "x.y.z.b" (like "4.2.2.135"), for major.minor.patch.build versions
    #   Available: "x.y.z.b" (like "4.2.2.135"), for major.minor.patch.build versions

    if [ $# -ne 2 ]; then
        echo "INTERNAL ERROR: Incorrect number of parameters passed to check_version_installable" >&2
        cleanup_and_exit 1
    fi

    # Current version installed
    local INS_MAJOR=`echo $1 | cut -d. -f1`
    local INS_MINOR=`echo $1 | cut -d. -f2`
    local INS_PATCH=`echo $1 | cut -d. -f3`
    local INS_BUILD=`echo $1 | cut -d. -f4`

    # Available version number
    local AVA_MAJOR=`echo $2 | cut -d. -f1`
    local AVA_MINOR=`echo $2 | cut -d. -f2`
    local AVA_PATCH=`echo $2 | cut -d. -f3`
    local AVA_BUILD=`echo $2 | cut -d. -f4`

    # Check bounds on MAJOR
    if [ $INS_MAJOR -lt $AVA_MAJOR ]; then
        return 0
    elif [ $INS_MAJOR -gt $AVA_MAJOR ]; then
        return 1
    fi

    # MAJOR matched, so check bounds on MINOR
    if [ $INS_MINOR -lt $AVA_MINOR ]; then
        return 0
    elif [ $INS_MINOR -gt $AVA_MINOR ]; then
        return 1
    fi

    # MINOR matched, so check bounds on PATCH
    if [ $INS_PATCH -lt $AVA_PATCH ]; then
        return 0
    elif [ $INS_PATCH -gt $AVA_PATCH ]; then
        return 1
    fi

    # PATCH matched, so check bounds on BUILD
    if [ $INS_BUILD -lt $AVA_BUILD ]; then
        return 0
    elif [ $INS_BUILD -gt $AVA_BUILD ]; then
        return 1
    fi

    # Version available is idential to installed version, so don't install
    return 1
}

getVersionNumber()
{
    # Parse a version number from a string.
    #
    # Parameter 1: string to parse version number string from
    #     (should contain something like mumble-4.2.2.135.universal.x86.tar)
    # Parameter 2: prefix to remove ("mumble-" in above example)

    if [ $# -ne 2 ]; then
        echo "INTERNAL ERROR: Incorrect number of parameters passed to getVersionNumber" >&2
        cleanup_and_exit 1
    fi

    echo $1 | sed -e "s/$2//" -e 's/\.universal\..*//' -e 's/\.x64.*//' -e 's/\.x86.*//' -e 's/-/./'
}

verifyNoInstallationOption()
{
    if [ -n "${installMode}" ]; then
        echo "$0: Conflicting qualifiers, exiting" >&2
        cleanup_and_exit 1
    fi

    return;
}

ulinux_detect_installer()
{
    INSTALLER=

    # If DPKG lives here, assume we use that. Otherwise we use RPM.
    type dpkg > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        INSTALLER=DPKG
    else
        INSTALLER=RPM
    fi
}

# $1 - The name of the package to check as to whether it's installed
check_if_pkg_is_installed() {
    if [ "$INSTALLER" = "DPKG" ]; then
        dpkg -s $1 2> /dev/null | grep Status | grep " installed" 1> /dev/null
    else
        rpm -q $1 2> /dev/null 1> /dev/null
    fi

    return $?
}

# $1 - The filename of the package to be installed
# $2 - The package name of the package to be installed
pkg_add() {
    pkg_filename=$1
    pkg_name=$2

    echo "----- Installing package: $2 ($1) -----"

    if [ -z "${forceFlag}" -a -n "$3" ]; then
        if [ $3 -ne 0 ]; then
            echo "Skipping package since existing version >= version available"
            return 0
        fi
    fi

    if [ "$INSTALLER" = "DPKG" ]; then
        dpkg --install --refuse-downgrade ${pkg_filename}.deb
    else
        rpm --install ${pkg_filename}.rpm
    fi
}

# $1 - The package name of the package to be uninstalled
# $2 - Optional parameter. Only used when forcibly removing omi on SunOS
pkg_rm() {
    echo "----- Removing package: $1 -----"
    if [ "$INSTALLER" = "DPKG" ]; then
        if [ "$installMode" = "P" ]; then
            dpkg --purge $1
        else
            dpkg --remove $1
        fi
    else
        rpm --erase $1
    fi
}

# $1 - The filename of the package to be installed
# $2 - The package name of the package to be installed
# $3 - Okay to upgrade the package? (Optional)
pkg_upd() {
    pkg_filename=$1
    pkg_name=$2
    pkg_allowed=$3

    echo "----- Updating package: $pkg_name ($pkg_filename) -----"

    if [ -z "${forceFlag}" -a -n "$pkg_allowed" ]; then
        if [ $pkg_allowed -ne 0 ]; then
            echo "Skipping package since existing version >= version available"
            return 0
        fi
    fi

    if [ "$INSTALLER" = "DPKG" ]; then
        [ -z "${forceFlag}" ] && FORCE="--refuse-downgrade"
        dpkg --install $FORCE ${pkg_filename}.deb

        export PATH=/usr/local/sbin:/usr/sbin:/sbin:$PATH
    else
        [ -n "${forceFlag}" ] && FORCE="--force"
        rpm --upgrade $FORCE ${pkg_filename}.rpm
    fi
}

getInstalledVersion()
{
    # Parameter: Package to check if installed
    # Returns: Printable string (version installed or "None")
    if check_if_pkg_is_installed $1; then
        if [ "$INSTALLER" = "DPKG" ]; then
            local version=`dpkg -s $1 2> /dev/null | grep "Version: "`
            getVersionNumber $version "Version: "
        else
            local version=`rpm -q $1 2> /dev/null`
            getVersionNumber $version ${1}-
        fi
    else
        echo "None"
    fi
}

shouldInstall_mysql()
{
    local versionInstalled=`getInstalledVersion mysql-cimprov`
    [ "$versionInstalled" = "None" ] && return 0
    local versionAvailable=`getVersionNumber $MYSQL_PKG mysql-cimprov-`

    check_version_installable $versionInstalled $versionAvailable
}

getInstalledVersion()
{
    # Parameter: Package to check if installed
    # Returns: Printable string (version installed or "None")
    if check_if_pkg_is_installed $1; then
        if [ "$INSTALLER" = "DPKG" ]; then
            local version="`dpkg -s $1 2> /dev/null | grep 'Version: '`"
            getVersionNumber "$version" "Version: "
        else
            local version=`rpm -q $1 2> /dev/null`
            getVersionNumber $version ${1}-
        fi
    else
        echo "None"
    fi
}

shouldInstall_docker()
{
    local versionInstalled=`getInstalledVersion docker-cimprov`
    [ "$versionInstalled" = "None" ] && return 0
    local versionAvailable=`getVersionNumber $CONTAINER_PKG docker-cimprov-`

    check_version_installable $versionInstalled $versionAvailable
}

#
# Executable code follows
#

ulinux_detect_installer

while [ $# -ne 0 ]; do
    case "$1" in
        --extract-script)
            # hidden option, not part of usage
            # echo "  --extract-script FILE  extract the script to FILE."
            head -${SCRIPT_LEN} "${SCRIPT}" > "$2"
            local shouldexit=true
            shift 2
            ;;

        --extract-binary)
            # hidden option, not part of usage
            # echo "  --extract-binary FILE  extract the binary to FILE."
            tail +${SCRIPT_LEN_PLUS_ONE} "${SCRIPT}" > "$2"
            local shouldexit=true
            shift 2
            ;;

        --extract)
            verifyNoInstallationOption
            installMode=E
            shift 1
            ;;

        --force)
            forceFlag=true
            shift 1
            ;;

        --install)
            verifyNoInstallationOption
            installMode=I
            shift 1
            ;;

        --purge)
            verifyNoInstallationOption
            installMode=P
            shouldexit=true
            shift 1
            ;;

        --remove)
            verifyNoInstallationOption
            installMode=R
            shouldexit=true
            shift 1
            ;;

        --restart-deps)
            # No-op for Docker, as there are no dependent services
            shift 1
            ;;

        --upgrade)
            verifyNoInstallationOption
            installMode=U
            shift 1
            ;;

        --version)
            echo "Version: `getVersionNumber $CONTAINER_PKG docker-cimprov-`"
            exit 0
            ;;

        --version-check)
            printf '%-18s%-15s%-15s%-15s\n\n' Package Installed Available Install?

            # docker-cimprov itself
            versionInstalled=`getInstalledVersion docker-cimprov`
            versionAvailable=`getVersionNumber $CONTAINER_PKG docker-cimprov-`
            if shouldInstall_docker; then shouldInstall="Yes"; else shouldInstall="No"; fi
            printf '%-18s%-15s%-15s%-15s\n' docker-cimprov $versionInstalled $versionAvailable $shouldInstall

            exit 0
            ;;

        --debug)
            echo "Starting shell debug mode." >&2
            echo "" >&2
            echo "SCRIPT_INDIRECT: $SCRIPT_INDIRECT" >&2
            echo "SCRIPT_DIR:      $SCRIPT_DIR" >&2
            echo "SCRIPT:          $SCRIPT" >&2
            echo >&2
            set -x
            shift 1
            ;;

        -? | --help)
            usage `basename $0` >&2
            cleanup_and_exit 0
            ;;

        *)
            usage `basename $0` >&2
            cleanup_and_exit 1
            ;;
    esac
done

if [ -n "${forceFlag}" ]; then
    if [ "$installMode" != "I" -a "$installMode" != "U" ]; then
        echo "Option --force is only valid with --install or --upgrade" >&2
        cleanup_and_exit 1
    fi
fi

if [ -z "${installMode}" ]; then
    echo "$0: No options specified, specify --help for help" >&2
    cleanup_and_exit 3
fi

# Do we need to remove the package?
set +e
if [ "$installMode" = "R" -o "$installMode" = "P" ]; then
    pkg_rm docker-cimprov

    if [ "$installMode" = "P" ]; then
        echo "Purging all files in container agent ..."
        rm -rf /etc/opt/microsoft/docker-cimprov /opt/microsoft/docker-cimprov /var/opt/microsoft/docker-cimprov
    fi
fi

if [ -n "${shouldexit}" ]; then
    # when extracting script/tarball don't also install
    cleanup_and_exit 0
fi

#
# Do stuff before extracting the binary here, for example test [ `id -u` -eq 0 ],
# validate space, platform, uninstall a previous version, backup config data, etc...
#

#
# Extract the binary here.
#

echo "Extracting..."

# $PLATFORM is validated, so we know we're on Linux of some flavor
tail -n +${SCRIPT_LEN_PLUS_ONE} "${SCRIPT}" | tar xzf -
STATUS=$?
if [ ${STATUS} -ne 0 ]; then
    echo "Failed: could not extract the install bundle."
    cleanup_and_exit ${STATUS}
fi

#
# Do stuff after extracting the binary here, such as actually installing the package.
#

EXIT_STATUS=0

case "$installMode" in
    E)
        # Files are extracted, so just exit
        cleanup_and_exit ${STATUS}
        ;;

    I)
        echo "Installing container agent ..."

        pkg_add $CONTAINER_PKG docker-cimprov
        EXIT_STATUS=$?
        ;;

    U)
        echo "Updating container agent ..."

        shouldInstall_docker
        pkg_upd $CONTAINER_PKG docker-cimprov $?
        EXIT_STATUS=$?
        ;;

    *)
        echo "$0: Invalid setting of variable \$installMode ($installMode), exiting" >&2
        cleanup_and_exit 2
esac

# Remove the package that was extracted as part of the bundle

[ -f $CONTAINER_PKG.rpm ] && rm $CONTAINER_PKG.rpm
[ -f $CONTAINER_PKG.deb ] && rm $CONTAINER_PKG.deb

if [ $? -ne 0 -o "$EXIT_STATUS" -ne "0" ]; then
    cleanup_and_exit 1
fi

cleanup_and_exit 0

#####>>- This must be the last line of this script, followed by a single empty line. -<<#####
